
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<meta name="keywords" content="alp gulec, system programming, computer science, algorithms, operating systems"/>
	<meta name="description" content="Personal website is about computer science"/>
	
	<title>Alp Güleç Personal Website</title>
	
	<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
	<link href="/files/css/theme.css" rel="stylesheet" type="text/css"/>
	<script src="/files/js/page.js" type="text/javascript"></script>
	<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EC8VHY4W24"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EC8VHY4W24');
</script></head>
<body onload="on_page_load()">
	<div class="page_div">
				<table class="page_table">
			<tr class="page_banner_row"><td><a href="/"><img src="/files/images/banner.png"/></a></td></tr>
			<tr class="page_menu_row"><td class="page_menu_column"><span class='page_menu_span'><a href='/'>Homepage</a></span><span class='page_menu_span'><a href='/projects'>Projects</a></span><span class='page_menu_span'><a href='/documents'>Documents</a></span><span class='page_menu_span'><a href='/notes'>Notes</a></span><span class='page_menu_span'><a href='/archive'>Archive</a></span><span class='page_menu_span'><a href='/about'>About</a></span><span class='social_icon_bar'><span class='contact_icon'><a href='/' onmouseover='prepare_contact_information_box(this)'><img src='/files/images/contact_icon.png' width='20' height='15'></a></span><span class='x_icon'><a href='https://www.x.com/alpgulec' target='_blank'><img src='/files/images/x_icon.png' width='15' height='15'></a></span></span></td></tr>
			<tr>
				<td>
					<!-- Center Table: Begin -->
					<table class="center_table">
						<tr>
							<td class="center_table_content_column">
								
<table class="content_table">
	<tr>
		<td class="content_table_column">
			<b><span class='content_title'><a href='/documents/13-specialized-spinlock'>Specialized Spinlock</a></span></b><pre class='pre_content'>In this article, I talk about thread-safety and a specific but common case of it. I didn’t cover the thread-safety concepts in detail and I briefly explain the related ones only. This article considers that the reader has some knowledge about thread-safety, operating system concepts and computer architecture.

Protecting the data from race condition is a complex job and there are various solutions. Generic thread-safety mechanisms (mutex, etc) work great but their performance impact on the system may be huge. In some cases, it is possible to develop lock-free algorithms or disable the locks, temporarily. Developing a customized thread-safety solution according to your needs, doesn’t only protect your data from race condition, it saves your system resources, speeding up your operations as well.

We will design a simple firewall that checks if the IP address of the client is allowed to show an example. Multiple threads will be executed and they will use a shared whitelist for this operation. We will keep the whitelist in a database and we won’t query it for every request. It is quite expensive. So, we will cache the data and update it (timely or depending on a trigger) ; a trigger would be better.

<b>CustomContainer</b> is our container for storing the allowed IP addresses. Consider it in a global or class scope and not thread-safe. Threads will share this container and IP address checker functions will only read it.

<b>IsAllowedIP</b> is our thread function. I won’t add exception handling to make the code simple as much as possible in the examples.

<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td> </td></tr><tr><td class='content_code_table_line_column'>3</td><td>// Thread function without synchronization</td></tr><tr><td class='content_code_table_line_column'>4</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>5</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>6</td><td>    return true;</td></tr><tr><td class='content_code_table_line_column'>7</td><td> </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  return false;</td></tr><tr><td class='content_code_table_line_column'>9</td><td>}</td></tr></table></pre>
and <b>UpdateData</b> is another thread function that is executed by another thread.

<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>2</td><td>  httpServerAccessList = GetUpdatedList();</td></tr><tr><td class='content_code_table_line_column'>3</td><td>}</td></tr></table></pre>
In short, <b>UpdateData</b> function updates the whitelist and <b>IsAllowedIP</b> tries to read it at the same time and the <b>find</b> function of <b>CustomContainer</b> will show undefined behavior because of modification.

Now, we will put a mutex and see what happens.
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td>mutex mtx;</td></tr><tr><td class='content_code_table_line_column'>3</td><td> </td></tr><tr><td class='content_code_table_line_column'>4</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>5</td><td>  // Lock_guard automatically releases the lock on destruction</td></tr><tr><td class='content_code_table_line_column'>6</td><td>  lock_guard&lt;mutex&gt; mutexLock(mtx);</td></tr><tr><td class='content_code_table_line_column'>7</td><td> </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>9</td><td>    return true;</td></tr><tr><td class='content_code_table_line_column'>10</td><td> </td></tr><tr><td class='content_code_table_line_column'>11</td><td>  return false;</td></tr><tr><td class='content_code_table_line_column'>12</td><td>}</td></tr><tr><td class='content_code_table_line_column'>13</td><td> </td></tr><tr><td class='content_code_table_line_column'>14</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>15</td><td>  lock_guard&lt;mutex&gt; mutexLock(mtx);</td></tr><tr><td class='content_code_table_line_column'>16</td><td>  httpServerAccessList = GetUpdatedList();</td></tr><tr><td class='content_code_table_line_column'>17</td><td>}</td></tr></table></pre>
We solved the race condition problem but the performance will be pretty bad. Only one <b>IsAllowedIP</b> thread can read <b>httpServerAccessList</b>. If we solve this problem in this way, using multi-threading is useless.

<b>mtx</b> is our mutual exclusion object in global scope and <b>lock_guard</b> is a mutex wrapper. We create it in a function's local scope. So, its destructor releases the lock automatically when the function ends. Every thread has its own stack. So, it is not shared. <b>mtx</b> is the same but <b>mutexLock</b> is different for all threads.

We need an improvement and I would like to start with mutex. Because mutex is not performance efficient. If a thread tries to acquire a mutex and can’t, goes to sleep immediately. So, overhead is huge and this impacts the performance. Also, its performance differs significantly according to the low-level implementations. For example, boost::mutex is better than std::mutex on Windows but std::mutex is better on Linux.

So, we could use spinlock. Spinlock is a good alternative for avoiding context switch overhead. It is a loop to keep the thread alive. The operation must be atomic. The thread will run until the context switch occurs on time interrupt. It won’t go to the sleep, immediately.

A spinlock in C++.
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>// Defined in global scope</td></tr><tr><td class='content_code_table_line_column'>2</td><td>atomic_flag lock = ATOMIC_FLAG_INIT;</td></tr><tr><td class='content_code_table_line_column'>3</td><td> </td></tr><tr><td class='content_code_table_line_column'>4</td><td>// ...</td></tr><tr><td class='content_code_table_line_column'>5</td><td>while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>6</td><td>// ...</td></tr><tr><td class='content_code_table_line_column'>7</td><td>// Critical code</td></tr><tr><td class='content_code_table_line_column'>8</td><td>// ...</td></tr><tr><td class='content_code_table_line_column'>9</td><td>lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>10</td><td>// ...</td></tr></table></pre>
As it seems, there is a while loop and an atomic operation. It atomically tests and sets the state of <b>lock</b>. The compiler will generate atomic CPU instructions. All CPU instructions are not atomic and today’s modern CPUs have microcodes. Even the <b>INC</b> instruction is not atomic. Because CPU reads the value, increases it and stores. <b>XCHG</b> instruction is atomic and used for implementing spinlock in low level. Thanks to atomic instructions, we are also able to implement lock-free algorithms in software level. But there is actually some locking mechanism on the hardware. <b>LOCK</b> prefix is used for atomic operations and it is redundant for <b>XCHG</b>. <b>LOCK</b> puts a memory barrier for synchronization. But it is not like putting a mutex and the overhead differs according to the architecture. It is pretty efficient hardware operation but, of course, you shouldn’t use it in everywhere.

Now let’s continue,
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td>atomic_flag lock = ATOMIC_FLAG_INIT;</td></tr><tr><td class='content_code_table_line_column'>3</td><td> </td></tr><tr><td class='content_code_table_line_column'>4</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>5</td><td>  // There is no need to protect a local variable</td></tr><tr><td class='content_code_table_line_column'>6</td><td>  bool result = false;</td></tr><tr><td class='content_code_table_line_column'>7</td><td> </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  // Lock</td></tr><tr><td class='content_code_table_line_column'>9</td><td>  while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>10</td><td> </td></tr><tr><td class='content_code_table_line_column'>11</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>12</td><td>    result = true;</td></tr><tr><td class='content_code_table_line_column'>13</td><td> </td></tr><tr><td class='content_code_table_line_column'>14</td><td>  // Unlock</td></tr><tr><td class='content_code_table_line_column'>15</td><td>  lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>16</td><td> </td></tr><tr><td class='content_code_table_line_column'>17</td><td>  return result;</td></tr><tr><td class='content_code_table_line_column'>18</td><td>}</td></tr><tr><td class='content_code_table_line_column'>19</td><td> </td></tr><tr><td class='content_code_table_line_column'>20</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>21</td><td>  while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>22</td><td>  </td></tr><tr><td class='content_code_table_line_column'>23</td><td>  httpServerAccessList = GetUpdatedList();     </td></tr><tr><td class='content_code_table_line_column'>24</td><td>  </td></tr><tr><td class='content_code_table_line_column'>25</td><td>  lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>26</td><td>}</td></tr></table></pre>
We replaced the mutex with a spinlock but it is like the other code. Only one <b>IsAllowedIP</b> thread will read <b>httpServerAccessList</b>. It is almost the same thing in a different color.

In addition to these, mostly, there is no need to use a complex thread-safety locking mechanism in this case. <b>IsAllowedIP</b> threads only read the data. They don’t modify it and <b>UpdateData</b> function is executed, very rarely. If UpdateData doesn’t run, race condition is not a problem. So, we could disable the spinlock, temporarily and we could enable it only when necessary.

So, we are changing the code,
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td>atomic_flag lock = ATOMIC_FLAG_INIT;</td></tr><tr><td class='content_code_table_line_column'>3</td><td>bool isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>4</td><td> </td></tr><tr><td class='content_code_table_line_column'>5</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>6</td><td>  bool result = false;</td></tr><tr><td class='content_code_table_line_column'>7</td><td> </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  // Lock</td></tr><tr><td class='content_code_table_line_column'>9</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>10</td><td>    while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>11</td><td> </td></tr><tr><td class='content_code_table_line_column'>12</td><td>  if (httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>13</td><td>    result = true;</td></tr><tr><td class='content_code_table_line_column'>14</td><td> </td></tr><tr><td class='content_code_table_line_column'>15</td><td>  // Unlock</td></tr><tr><td class='content_code_table_line_column'>16</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>17</td><td>    lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>18</td><td> </td></tr><tr><td class='content_code_table_line_column'>19</td><td>  return result;</td></tr><tr><td class='content_code_table_line_column'>20</td><td>}</td></tr><tr><td class='content_code_table_line_column'>21</td><td> </td></tr><tr><td class='content_code_table_line_column'>22</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>23</td><td>  isEnabled = true;</td></tr><tr><td class='content_code_table_line_column'>24</td><td>  while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>25</td><td>      </td></tr><tr><td class='content_code_table_line_column'>26</td><td>  httpServerAccessList = GetUpdatedList();</td></tr><tr><td class='content_code_table_line_column'>27</td><td>  </td></tr><tr><td class='content_code_table_line_column'>28</td><td>  isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>29</td><td>  lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>30</td><td>}</td></tr></table></pre>
And now, we enable and disable the spinlock mechanism depending on the <b>UpdateData</b> function. But, there is a critical problem in this code. Before mentioning it, I would like to talk about branch penalty. Because branch penalty affects the pipeline performance. So, using conditions (if, while, etc) may decrease the performance. But, all modern CPUs have branch prediction mechanisms and they can eliminate the branch penalties. Our conditions are extremely simple to be predicted.

I just want to talk about the critical problem now. We enable and disable the spinlock but context switch may occur when <b>IsAllowedIP</b> is not completed yet.

I mean,
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>2</td><td>  bool result = false;</td></tr><tr><td class='content_code_table_line_column'>3</td><td> </td></tr><tr><td class='content_code_table_line_column'>4</td><td>  // Lock</td></tr><tr><td class='content_code_table_line_column'>5</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>6</td><td>    while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>7</td><td>  </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  //WE ARE HERE =&gt;</td></tr><tr><td class='content_code_table_line_column'>9</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>10</td><td>    result = true;</td></tr><tr><td class='content_code_table_line_column'>11</td><td> </td></tr><tr><td class='content_code_table_line_column'>12</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>13</td><td>    lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>14</td><td> </td></tr><tr><td class='content_code_table_line_column'>15</td><td>  return result;</td></tr><tr><td class='content_code_table_line_column'>16</td><td>}</td></tr></table></pre>
<b>UpdateData</b> function will take the control, modify <b>httpServerAccessList</b> and when <b>IsAllowedIP</b> continues, a problem will occur. So, we must be sure about all <b>IsAllowedIP</b> threads are done.

Therefore, we must add a counter to track threads.
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td>atomic_flag lock = ATOMIC_FLAG_INIT;</td></tr><tr><td class='content_code_table_line_column'>3</td><td>bool isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>4</td><td>atomic&lt;int&gt; runningThreads {0};</td></tr><tr><td class='content_code_table_line_column'>5</td><td> </td></tr><tr><td class='content_code_table_line_column'>6</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>7</td><td>  bool result = false;</td></tr><tr><td class='content_code_table_line_column'>8</td><td> </td></tr><tr><td class='content_code_table_line_column'>9</td><td>  // Lock</td></tr><tr><td class='content_code_table_line_column'>10</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>11</td><td>    while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>12</td><td> </td></tr><tr><td class='content_code_table_line_column'>13</td><td>  runningThreads++;</td></tr><tr><td class='content_code_table_line_column'>14</td><td> </td></tr><tr><td class='content_code_table_line_column'>15</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>16</td><td>    result = true;</td></tr><tr><td class='content_code_table_line_column'>17</td><td> </td></tr><tr><td class='content_code_table_line_column'>18</td><td>  // Unlock</td></tr><tr><td class='content_code_table_line_column'>19</td><td>  if(isEnabled)</td></tr><tr><td class='content_code_table_line_column'>20</td><td>    lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>21</td><td> </td></tr><tr><td class='content_code_table_line_column'>22</td><td>  runningThreads--;</td></tr><tr><td class='content_code_table_line_column'>23</td><td></td></tr><tr><td class='content_code_table_line_column'>24</td><td>  return result;</td></tr><tr><td class='content_code_table_line_column'>25</td><td>}</td></tr><tr><td class='content_code_table_line_column'>26</td><td> </td></tr><tr><td class='content_code_table_line_column'>27</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>28</td><td>  isEnabled = true;</td></tr><tr><td class='content_code_table_line_column'>29</td><td>  while(runningThreads &gt; 0);</td></tr><tr><td class='content_code_table_line_column'>30</td><td> </td></tr><tr><td class='content_code_table_line_column'>31</td><td>  while(lock.test_and_set(memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>32</td><td>      </td></tr><tr><td class='content_code_table_line_column'>33</td><td>  httpServerAccessList = GetUpdatedList();</td></tr><tr><td class='content_code_table_line_column'>34</td><td>    </td></tr><tr><td class='content_code_table_line_column'>35</td><td>  isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>36</td><td>  lock.clear(memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>37</td><td>}</td></tr></table></pre>
<b>runningThreads</b> is an atomic variable and it works in the same manner on the hardware. It is lock-free but all atomic variables may not be lock-free. You can use <b>is_lock_free</b> function to check this. <b>IsAllowedIP</b> threads increase, decrease it and a loop in <b>UpdateData</b> function checks it before acquiring the lock. <b>UpdateData</b> runs, very rarely (maybe in an hour, day, month, etc.). So, we don’t need to do excessive optimizations on it.

Additionally, you might think that what if <b>lock</b> was already unlocked and <b>isEnabled</b> is true. It won’t be an issue. Because it just sets the flag. It is safe to call.

After all of these, I want to create a custom spinlock class to make the code neater and finish this text.

<b>CustomSpinlock.hpp</b>
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>#pragma once</td></tr><tr><td class='content_code_table_line_column'>2</td><td> </td></tr><tr><td class='content_code_table_line_column'>3</td><td>#include &lt;atomic&gt;</td></tr><tr><td class='content_code_table_line_column'>4</td><td> </td></tr><tr><td class='content_code_table_line_column'>5</td><td>class CustomSpinlock final {</td></tr><tr><td class='content_code_table_line_column'>6</td><td> public:</td></tr><tr><td class='content_code_table_line_column'>7</td><td>  CustomSpinlock() = default;  </td></tr><tr><td class='content_code_table_line_column'>8</td><td>  ~CustomSpinlock() = default;</td></tr><tr><td class='content_code_table_line_column'>9</td><td> </td></tr><tr><td class='content_code_table_line_column'>10</td><td>  void Lock();</td></tr><tr><td class='content_code_table_line_column'>11</td><td>  void Release();</td></tr><tr><td class='content_code_table_line_column'>12</td><td> </td></tr><tr><td class='content_code_table_line_column'>13</td><td>  void TakeControl();</td></tr><tr><td class='content_code_table_line_column'>14</td><td>  void GiveControl();</td></tr><tr><td class='content_code_table_line_column'>15</td><td> </td></tr><tr><td class='content_code_table_line_column'>16</td><td> private:</td></tr><tr><td class='content_code_table_line_column'>17</td><td>  bool _isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>18</td><td>  std::atomic_flag _lock = ATOMIC_FLAG_INIT;</td></tr><tr><td class='content_code_table_line_column'>19</td><td>  std::atomic&lt;int&gt; _runningThreads {0};</td></tr></table></pre>

<b>CustomSpinlock.cpp</b>
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>#include &quot;CustomSpinlock.hpp&quot;</td></tr><tr><td class='content_code_table_line_column'>2</td><td> </td></tr><tr><td class='content_code_table_line_column'>3</td><td>void CustomSpinlock::Lock() {</td></tr><tr><td class='content_code_table_line_column'>4</td><td>  if(_isEnabled)</td></tr><tr><td class='content_code_table_line_column'>5</td><td>    while(_lock.test_and_set(std::memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>6</td><td>  </td></tr><tr><td class='content_code_table_line_column'>7</td><td>  _runningThreads++; </td></tr><tr><td class='content_code_table_line_column'>8</td><td>}</td></tr><tr><td class='content_code_table_line_column'>9</td><td> </td></tr><tr><td class='content_code_table_line_column'>10</td><td>void CustomSpinlock::Release() { </td></tr><tr><td class='content_code_table_line_column'>11</td><td>  if(_isEnabled)</td></tr><tr><td class='content_code_table_line_column'>12</td><td>    _lock.clear(std::memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>13</td><td></td></tr><tr><td class='content_code_table_line_column'>14</td><td>  _runningThreads--;</td></tr><tr><td class='content_code_table_line_column'>15</td><td>}</td></tr><tr><td class='content_code_table_line_column'>16</td><td> </td></tr><tr><td class='content_code_table_line_column'>17</td><td>void CustomSpinlock::TakeControl() {</td></tr><tr><td class='content_code_table_line_column'>18</td><td>  _isEnabled = true;</td></tr><tr><td class='content_code_table_line_column'>19</td><td>  while(_runningThreads &gt; 0);</td></tr><tr><td class='content_code_table_line_column'>20</td><td> </td></tr><tr><td class='content_code_table_line_column'>21</td><td>  while(_lock.test_and_set(std::memory_order_acquire));</td></tr><tr><td class='content_code_table_line_column'>22</td><td>}</td></tr><tr><td class='content_code_table_line_column'>23</td><td> </td></tr><tr><td class='content_code_table_line_column'>24</td><td>void CustomSpinlock::GiveControl() {</td></tr><tr><td class='content_code_table_line_column'>25</td><td>  _isEnabled = false;</td></tr><tr><td class='content_code_table_line_column'>26</td><td>  _lock.clear(std::memory_order_release);</td></tr><tr><td class='content_code_table_line_column'>27</td><td>}</td></tr></table></pre>

<b>Usage:</b>
<pre class='content_code_table_pre'><table class='content_code_table'><tr><td class='content_code_table_line_column'>1</td><td>CustomContainer&lt;string&gt; httpServerAccessList;</td></tr><tr><td class='content_code_table_line_column'>2</td><td>CustomSpinlock spinlock;</td></tr><tr><td class='content_code_table_line_column'>3</td><td> </td></tr><tr><td class='content_code_table_line_column'>4</td><td>bool IsAllowedIP(const string&amp; ipAddress) {</td></tr><tr><td class='content_code_table_line_column'>5</td><td>  bool result = false;</td></tr><tr><td class='content_code_table_line_column'>6</td><td> </td></tr><tr><td class='content_code_table_line_column'>7</td><td>  spinlock.Lock();</td></tr><tr><td class='content_code_table_line_column'>8</td><td> </td></tr><tr><td class='content_code_table_line_column'>9</td><td>  if(httpServerAccessList.find(ipAddress) != httpServerAccessList.end())</td></tr><tr><td class='content_code_table_line_column'>10</td><td>    result = true;</td></tr><tr><td class='content_code_table_line_column'>11</td><td> </td></tr><tr><td class='content_code_table_line_column'>12</td><td>  spinlock.Release();</td></tr><tr><td class='content_code_table_line_column'>13</td><td> </td></tr><tr><td class='content_code_table_line_column'>14</td><td>  return result;</td></tr><tr><td class='content_code_table_line_column'>15</td><td>}</td></tr><tr><td class='content_code_table_line_column'>16</td><td> </td></tr><tr><td class='content_code_table_line_column'>17</td><td>void UpdateData() {</td></tr><tr><td class='content_code_table_line_column'>18</td><td>  spinlock.TakeControl();</td></tr><tr><td class='content_code_table_line_column'>19</td><td>      </td></tr><tr><td class='content_code_table_line_column'>20</td><td>  httpServerAccessList = GetUpdatedList();</td></tr><tr><td class='content_code_table_line_column'>21</td><td>      </td></tr><tr><td class='content_code_table_line_column'>22</td><td>  spinlock.GiveControl();</td></tr><tr><td class='content_code_table_line_column'>23</td><td>}</td></tr></table></pre></pre>		</td>
	</tr>
</table>							</td>
							<td class="center_table_sidebar_column">
<div class="sidebar_div">
	<table class="sidebar_table">
		<tr class="sidebar_table_row_header">
			<td>
				Information
			</td>
		</tr>
		<tr class="sidebar_table_row_content">
			<td class="sidebar_table_text_content_column">
				I completely translated my website into the English language. It is time for <a  href="/notes/14-a-new-start">a new start</a>.			</td>
		</tr>
	</table>

	<table class="sidebar_table">
		<tr class="sidebar_table_row_header">
			<td>
				Most Read
			</td>
		</tr>
		<tr class="sidebar_table_row_content">
			<td class="sidebar_table_list_content_column">
				<ul class="sidebar_table_list">
				<li class='sidebar_table_list_item'><a href='/projects/2-experimental-programming-language-and-win32-ide'>Experimental Programming Language and Win32 IDE</a></li><li class='sidebar_table_list_item'><a href='/projects/33-scientific-operating-system'>Scientific Operating System</a></li><li class='sidebar_table_list_item'><a href='/projects/32-scientific-calculation-library'>Scientific Calculation Library</a></li><li class='sidebar_table_list_item'><a href='/documents/13-specialized-spinlock'>Specialized Spinlock</a></li><li class='sidebar_table_list_item'><a href='/archive/9-detective-bit-bytes-toolbox-the-time-machine-archived'>Detective Bit Bytes' Toolbox - The Time Machine (Archived)</a></li>				</ul>
			</td>
		</tr>
	</table>

	<table class="sidebar_table">
		<tr class="sidebar_table_row_header">
			<td>
				Recently Added
			</td>
		</tr>
		<tr class="sidebar_table_row_content">
			<td class="sidebar_table_list_content_column">
				<ul class="sidebar_table_list">
				<li class='sidebar_table_list_item'><a href='/archive/19-alpgulec-com'>alpgulec.com</a></li><li class='sidebar_table_list_item'><a href='/archive/9-detective-bit-bytes-toolbox-the-time-machine-archived'>Detective Bit Bytes' Toolbox - The Time Machine (Archived)</a></li><li class='sidebar_table_list_item'><a href='/notes/14-a-new-start'>A New Start</a></li><li class='sidebar_table_list_item'><a href='/archive/18-bilimsehri-com-closed-down'>bilimsehri.com (Closed Down)</a></li><li class='sidebar_table_list_item'><a href='/archive/17-reverse-engineering-documents-archived'>Reverse Engineering Documents (Archived)</a></li>				</ul>
			</td>
		</tr>
	</table>
</div></td>
						</tr>
					</table>
					<!-- Center Table: End -->
				</td>
			</tr>
			<tr class="page_footer_row"><td><span class="copyright_text">Alp Güleç © 2007 - <script>print_year()</script></span></td></tr>
		</table>
	</div>
</body>
</html>

